import sysfrom headers import *def read_IP_header(file, packet_num):    # read packet header    buffer = file.read(16)    packet = packets()    packet.set_packet_number(packet_num)    packet.packet_header.set_ts_sec(buffer[0:4])    packet.packet_header.set_ts_usec(buffer[4:8])    packet.packet_header.set_incl_len(buffer[8:12])    # read Ethernet header, since it doesn't need for this analysis    buffer = file.read(14)    # read IP header    buffer = file.read(20)    packet.IP_header.set_ip_header_len(buffer[0])    packet.IP_header.set_total_len(buffer[2:4])    packet.IP_header.set_ID(buffer[4:6])    packet.IP_header.set_flags(buffer[6])    packet.IP_header.set_fragment_offset(buffer[6:8])    packet.IP_header.set_TTL(buffer[8])    packet.IP_header.set_protocol(buffer[9])    packet.IP_header.set_src_IP(buffer[12:16])    packet.IP_header.set_dst_IP(buffer[16:20])    # print("packet {} incl_len :{} protocol :{} timestamp :{}".format(packet_num, packet.packet_header.incl_len, packet.IP_header.protocol, packet.get_timestamp()))    if packet.IP_header.protocol == 1:        file_read = 0        # ICMP protocol        buffer = file.read(8)        packet.ICMP_header.set_type(buffer[0])        packet.ICMP_header.set_code(buffer[1])        # ICMP error message included        if packet.ICMP_header.type == 3 or packet.ICMP_header.type == 11:            file_read += 20            buffer = file.read(20)            packet.ICMP_header.set_orig_protocol(buffer[9])            packet.ICMP_header.set_orig_src_IP(buffer[12:16])            packet.ICMP_header.set_orig_dst_IP(buffer[16:20])            orig_ip_header_len = (buffer[0] % 16) * 4            if orig_ip_header_len > 20:                file.read(orig_ip_header_len - 20)            # error message includes ICMP protocol message -> captured in Windows            if packet.ICMP_header.orig_protocol == 1:                file_read += 8                buffer = file.read(8)                packet.ICMP_header.set_orig_seq(buffer[6:8])            # error message includes UDP protocol message -> captured in Linux            elif packet.ICMP_header.orig_protocol == 17:                file_read += 8                buffer = file.read(8)                packet.ICMP_header.set_orig_src_port(buffer[0:2])                packet.ICMP_header.set_orig_dst_port(buffer[2:4])        # ICMP message sent from client        elif packet.ICMP_header.type == 8:            packet.ICMP_header.set_seq_number(buffer[6:8])        # ICMP message with echo reply -> captured in Windows        elif packet.ICMP_header.type == 0:            packet.ICMP_header.set_orig_seq(buffer[6:8])        file.read(packet.packet_header.incl_len - (42 + file_read))    elif packet.IP_header.protocol == 17:        # UDP protocol sent from client        buffer = file.read(8)        packet.UDP_header.set_src_port(buffer[0:2])        packet.UDP_header.set_dst_port(buffer[2:4])        packet.UDP_header.set_udp_header_len(buffer[4:6])        # print(packet.UDP_header.src_port, packet.UDP_header.dst_port, packet_num)        file.read(packet.packet_header.incl_len - 42)    else:        # Other than UDP or ICMP messages, these will be ignored for this program        file.read(packet.packet_header.incl_len - 34)    return packetdef read_global_header(file):    buffer = file.read(24)    global_header = global_Header()    global_header.set_magic_num(buffer[0:4])    global_header.set_this_zone(buffer[8:12])def OS_check(packets):    # sorted_packets = sorted(packets, key=lambda packet: (packet.IP_header.ttl_value, packet.packet_number))    for packet in packets:        if (packet.ICMP_header.orig_src_port != 0 and packet.ICMP_header.orig_seq == 0):            # Captured in Linux            return 1        elif (packet.ICMP_header.orig_seq != 0 and packet.ICMP_header.orig_src_port == 0):            # Captured in Windows            return 2def implement_orig_data_to_fragment(packets, packet_num):    for i in range(0, packet_num-1):        if packets[i].IP_header.flags == 2:            for j in range(i+1, packet_num-1):                if packets[j].IP_header.flags == 0 and packets[j].IP_header.protocol == 17 and packets[i].IP_header.get_src_IP() == packets[j].IP_header.get_src_IP():                    packets[j].UDP_header.set_src_port(pack('>H', packets[i].UDP_header.src_port))                    # print(i,j, packets[i].UDP_header.src_port, packets[j].UDP_header.src_port)                    break                elif packets[j].IP_header.flags == 0 and packets[j].IP_header.protocol == 1:                    packets[j].ICMP_header.set_orig_seq(pack('>H', packets[i].ICMP_header.orig_seq))                    # print(i,j, packets[i].ICMP_header.orig_seq)                    breakdef print_inter_routers_linux(packets, packet_num, dst_IP):    print("\nThe IP addresses of the intermediate destination nodes:")    int_routers = {}    ttl = {}    for i in range(0, packet_num-1):        if packets[i].IP_header.protocol == 17:            for j in range(i+1, packet_num-1):                if (packets[j].ICMP_header.type == 11 or packets[j].ICMP_header.type == 3) and packets[i].UDP_header.src_port == packets[j].ICMP_header.orig_src_port:                    if packets[j].IP_header.get_src_IP() not in int_routers:                        int_routers[packets[j].IP_header.get_src_IP()] = [packets[j].get_RTT(packets[i])]                        # ttl[packets[j].IP_header.get_src_IP()] = [packets[i].IP_header.ttl_value]                    else:                        int_routers[packets[j].IP_header.get_src_IP()].append(packets[j].get_RTT(packets[i]))                        # ttl[packets[j].IP_header.get_src_IP()].append(packets[i].IP_header.ttl_value)    count = 1    for ip in int_routers:        if ip != dst_IP:            print("\trouter {}: {}".format(count, ip))            # print("\trouter {}: {} ttl: {}".format(count, ip, ttl[ip]))            count += 1    return int_routersdef print_inter_routers_windows(packets, packet_num, dst_IP):    print("\nThe IP addresses of the intermediate destination nodes:")    int_routers = {}    ttl = {}    for i in range(0, packet_num-1):        if packets[i].ICMP_header.type == 8:            for j in range(i+1, packet_num-1):                if (packets[j].ICMP_header.type == 0 or packets[j].ICMP_header.type == 11) and packets[i].ICMP_header.seq == packets[j].ICMP_header.orig_seq:                    if packets[j].IP_header.get_src_IP() not in int_routers:                        int_routers[packets[j].IP_header.get_src_IP()] = [packets[j].get_RTT(packets[i])]                        # ttl[packets[j].IP_header.get_src_IP()] = [packets[i].IP_header.ttl_value]                    else:                        int_routers[packets[j].IP_header.get_src_IP()].append(packets[j].get_RTT(packets[i]))                        # ttl[packets[j].IP_header.get_src_IP()].append(packets[i].IP_header.ttl_value)    count = 1    for ip in int_routers:        if ip != dst_IP:            print("\trouter {}: {}".format(count, ip))            # print("\trouter {}: {} ttl: {}".format(count, ip, ttl[ip]))            count += 1    return int_routersdef print_protocol(packets):    protocols = set()    for packet in packets:        protocol = packet.IP_header.protocol        if protocol == 1 or protocol == 17:            protocols.add(protocol)    print("\nThe values in the protocol field of IP headers:")    if 1 in protocols and 17 in protocols:        print("\t1: ICMP\n\t17: UDP\n")    elif 1 in protocols and 17 not in protocols:        print("\t1: ICMP\n")    elif 1 not in protocols and 17 in protocols:        print("\t17: UDP\n")def print_fragment_packet(packets, packet_num):    for i in range(0, packet_num-1):        if packets[i].IP_header.flags == 2:            for j in range(i, packet_num-1):                if packets[j].IP_header.flags == 0:                    print("The number of fragments created from the original datagram id {} is: {}".format(packets[j].IP_header.id, j-i+1))                    print("The offset of the last fragment is: {}\n".format(packets[j].IP_header.fragment_offset))                    breakdef sd_calculator(mean, rtt_values):    deviation = [(x - mean) ** 2 for x in rtt_values]    return (sum(deviation) / len(rtt_values)) ** 0.5def print_RTT_average(src_IP, int_routers):    for ip in int_routers:        mean = sum(int_routers[ip])/len(int_routers[ip])        sd = sd_calculator(mean, int_routers[ip])        print("The avg RTT between {} and {} is: {:.3f}ms, the s.d. is: {:.3f}ms".format(src_IP, ip, mean, sd))def print_ttl(packets, src_IP, type_OS):    """This function is just for requirement 2 not for coding assignment"""    ttl = {}    if type_OS == 1:        for packet in packets:            if packet.IP_header.protocol == 17 and packet.IP_header.get_src_IP() == src_IP:                if packet.IP_header.ttl_value not in ttl:                    ttl[packet.IP_header.ttl_value] = 1                else:                    ttl[packet.IP_header.ttl_value] += 1        sort_ttl = sorted(ttl)        for k in sort_ttl:            print("{}: {}\t".format(k, ttl[k]), end="")    else:        for packet in packets:            if packet.IP_header.protocol == 1 and packet.IP_header.get_src_IP() == src_IP:                if packet.IP_header.ttl_value not in ttl:                    ttl[packet.IP_header.ttl_value] = 1                else:                    ttl[packet.IP_header.ttl_value] += 1        sort_ttl = sorted(ttl)        for k in sort_ttl:            print("{}: {}\t".format(k, ttl[k]), end="")    print()def print_result(packets, packet_num, type_OS):    implement_orig_data_to_fragment(packets, packet_num)    if type_OS == 1:        for packet in packets:            if packet.ICMP_header.code == 3:                print("The IP address of the source node: {}".format(packet.IP_header.get_dst_IP()))                print("The IP address of the destination node: {}".format(packet.IP_header.get_src_IP()))                src_IP = packet.IP_header.get_dst_IP()                dst_IP = packet.IP_header.get_src_IP()                break        int_routers = print_inter_routers_linux(packets, packet_num, dst_IP)    else:        for packet in packets:            if packet.ICMP_header.type == 8:                print("The IP address of the source node: {}".format(packet.IP_header.get_src_IP()))                print("The IP address of the destination node: {}".format(packet.IP_header.get_dst_IP()))                src_IP = packet.IP_header.get_src_IP()                dst_IP = packet.IP_header.get_dst_IP()                break        int_routers = print_inter_routers_windows(packets, packet_num, dst_IP)    print_protocol(packets)    print_fragment_packet(packets, packet_num)    print_RTT_average(src_IP, int_routers)    # print_ttl(packets, src_IP, type_OS)def main():    packets = []    packet_num = 1    argc = len(sys.argv)    if argc < 2 or argc > 2:        print("please provide right file name")    file_name = sys.argv[1]    with open(file_name, "rb") as file:        read_global_header(file)        while True:            try:                packet = read_IP_header(file, packet_num)                if packet:                    packets.append(packet)                    packet_num += 1            except:                break    type_OS = OS_check(packets)    print_result(packets, packet_num, type_OS)if __name__ == "__main__":    main()